<h1 id="cve-2020-0609-cve-2020-0610">CVE-2020-0609 &amp; CVE-2020-0610</h1>
<h2 id="bug-overview">Bug Overview</h2>
<p>For Windows RDP service based on UDP, the application(service) has to handle the incoming packets and re-assemble them in the correct order as well as ensure that no parts are missing.</p>
<p>This information is obtained from the packet headers which have the following fields: - <code>fragment id</code> : Denotes the fragment’s position in the sequence - <code>num_fragments</code> : Denotes the total number of fragment in the sequence - <code>fragment_length</code> : Denotes the length of the fragment’s data</p>
<p>The implementation of the packet handler in the Windows RDP service introduces some bugs. The below mentioned code snippets are parts of this handler function being used to demonstrate the bugs.</p>
<h3 id="cve-2020-0609">1. CVE-2020-0609</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="cf">if</span> ((<span class="kw">this</span>-&gt;bytes_written + packet-&gt;fragment_len) &gt; <span class="kw">this</span>-&gt;buffer_size)</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">return</span> error;</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">    some more code</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">memcpy_s(&amp;<span class="kw">this</span>-&gt;buffer[<span class="dv">1000</span> * packet-&gt;fragment_id], <span class="dv">1000</span>, &amp;packet-&gt;fragment, packet-&gt;fragment_len);</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">this</span>-&gt;bytes_written += packet-&gt;fragment_len;</a></code></pre></div>
<p>The first line of the above code snippet is a <strong>bounds check</strong> on the (re-assembly) buffer. <code>memcpy_s</code> copies each fragment to an offset in the buffer which is calculated using the <code>fragment_id</code>, while the third line notes the update of the <code>bytes_written</code> variable being used in the bounds check.</p>
<p>Noting that the offset is not being used in the bounds check, we realize that this is a simple buffer overflow in which we control both the offset and the length of the data being written.</p>
<h3 id="cve-2020-0610">2. CVE-2020-0610</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="cf">if</span> (<span class="kw">this</span>-&gt;frag_received[fragment_id]) </a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="cf">return</span> ok;</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">/*</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">    some more code</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">this</span>-&gt;frag_received[fragment_id] = TRUE;</a></code></pre></div>
<pre><code>This code snippet shows that whenever any packet is verified, it&#39;s marked as received so as to not worry about the same packet being received multiple times. The array `this-&gt;frag_received` has space for only upto 64 entries, but the `fragment_id` can be any number between 0 to 65535; and hence, this also is a buffer overflow, however with each received fragment just 1 bit is being modified.</code></pre>
<h2 id="environment">Environment</h2>
<p>A local VM running Windows Server 2019 () has been set up, and UDP mode of Remote Desktop Gateway has been enabled on the same. No additional configurations needs to be set up.</p>
<p>Our code to exploit the vulnerability is as follows: &gt; insert exploit code latest</p>
<h2 id="report">Report</h2>
<p>We have managed to attack the vulnerability in the following two ways -</p>
<h3 id="scanning-for-the-vulnerability">1. Scanning for the vulnerability</h3>
<p><strong>CVE-2020-0610</strong> has been scanned for, using a crafted packet whose <code>fragment_id</code> has been (maliciously) chosen to be <code>65</code>(along with <code>num_fragments</code> being <code>66</code> since it has to be <code>&gt; fragment_id</code>).<br />
Such a packet is not acceptable on the patched version and returns an error(patched version has a check saying <code>packet-&gt;fragment_id &gt; 64</code> returns error); while the unpatched version returns no error but goes on executing further. Thus, no error received demonstrates that the vulnerability exists.</p>
<p>Scanning for solely <strong>CVE-2020-0609</strong> seems quite difficult since the buffer is supposed to be able to accomodate atleast the maximum number of fragments truly possible(which is <code>64</code> actually) and therefore, the buffer size would be atleast <code>64*1000</code> bytes and in such a case, a buffer overflow in <code>this-&gt;buffer</code> is impossible to happen with <code>fragment_id &lt; 64</code>. (The buffer is long enough to prevent from overwriting neighbouring data with just <strong>CVE-2020-0609</strong>).</p>
<h3 id="dosing-the-host">2. DoSing the host</h3>
<p>The host can be DoSed by exploiting <strong>CVE-2020-0610</strong> using crafted packets having <code>fragment_id &gt;= 64</code>. Our exploit connects to the server multiple times and sends such malicious packets over and over again, causing the service to eventually be shut down.</p>
<p>In our exploit, we’ve tried to not trigger the other vulnerability by choosing the fragments to have <code>fragment_size</code> of <code>1000</code> bytes and sending the fragments with increasing <code>fragment_id</code>; such as to ensure that <code>this-&gt;bytes_written</code> gets incremented by exactly <code>1000</code>(which is also the number of bytes being copied into the buffer). However, since the underlying protocol is UDP, we cannot be definitely sure that this is the case.</p>
<p>Once again, exploiting solely <strong>CVE-2020-0609</strong> to DoS the host is impossible due to the exact same reason as mentioned above.</p>
<blockquote>
<p>Note that both the exploits could be exploited simultaneously but that doesn’t add to anything.</p>
</blockquote>
